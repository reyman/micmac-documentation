= gestion des départs

== Signature

Une seule fonction regroupe actuellement l'ensemble des traitements permettant

- Le calcul des populations destinés à partir
- La construction des agents avions `MobileGroup`


.Arguments de la fonction
[options="header"]
|===
| argument de la fonction |signification
| #cumulated-pop-flight-expected-float| population cumulée
| #instantaneous-total-population-to-fly | stock de population susceptible de partir, cumulé sur l'ensemble des noeuds.
| #airplane-size | taille de l'avion 
| #strategy-redistribution | booléen pour indiquer si il y a redistribution ou pas des populations en cas de non départ
|===

Les populations (`#cumulated-pop-flight-expected-float` et `#instantaneous-total-population-to-fly`) qui sont passés en paramètres de cette fonction sont mis à jour à chaque nouvelle itération du modèle (`ticks`). Le calcul de ces populations est décrit sur la page décrivant la link:./procedure-principale.adoc[procédure principale].

== Mise à jour de la population de chaque noeud

Première partie, on calcule au niveau des noeud la population qui va être autorisé à voler.


[source,bash]
----
    ask nodes  
    [ 
      let my-instantaneous-total-population-to-fly #instantaneous-total-population-to-fly / number-nodes //<1>
      set stock-to-flight stock-to-flight + my-instantaneous-total-population-to-fly // <2>
    ]

----

<1> On rapporte cette population à chaque noeud. En réalité, `#instantaneous-total-population-to-fly` est une constante qui n'a pas de raison de varier, car celle-ci découle du calibrage. On notera ici que l'on passe d'un entier à un flottant au niveau de la population.

<2> On la stocke au niveau de chaque aéroport, car cette population se cumule.

On assume ici le fait que la populaiton sur le noeuf est toujours plus grande que la population amené à voyager, ce qui explique l'absence de code testant cette hypothèse. En effet, il est important de noter ici que cette population reste abstraite. Tant que les agents ne montent pas véritablement dans l'avion, la population réelle de SIR de l'aéroport n'est pas imputé.

== Résolution des autorisations

=== Premier bloc 

[source,bash]
----
 ask nodes with [out-airport = 1 and stock-to-flight >= gairplane-size ] 
  [
  ... 
  ]
----

On travaille sur un ensemble d'aéroports dont on sait la sortie ouverte (`out-airport = 1`), et pour lequel il existe une population prete à partir supérieure à la taille minimale d'un avion (par défaut 80) 

Dans ce premier bloc, on initialise les valeurs suivantes :

[source,bash]
----
    set has-one-plane-left-airport? true
    set pop-to-fly  int(stock-to-flight) // <1>
    set stock-to-flight stock-to-flight - pop-to-fly ; we consider we empty the stocks ! // <2>   
    set sum-pop-flight-expected sum-pop-flight-expected + pop-to-fly // <3>
----
<1> On arrondie le stock de population (float) pour le ramener à une valeur entière (int)
<2> On vide ce stock, mais attention, ici on conserve ce résidus de population faisant suite à cette discrétisation de la ligne précédente.
<3> Cette population *est mobilisé pour partir*, ce qui ne sera peut être pas le cas en réalité, du fait des stratégies. Ce qui explique le *expected* dans le nom de cette variable.

[source,bash]
----
 ifelse(any? (([link-neighbors] of self) with [in-airport = 1]) ) 
    [
     // <1>
    ]
    [
     // <2>
    ]
----

La condition teste ensuite pour chacun des aéroports de cet ensemble (`out-airport = 1`) si il existe au moins un un aéroport voisin, dont l'entrée (`in-airport`) est disponible pour recevoir un vol. 

<1> Si c'est le cas (`in-airport = 1` et `out-airport = 1`), alors on execute la boucle suivante qui construit et remplie les avions. 

[source,bash]
----
    while [pop-to-fly >= #airplane-size]
    [
     ...
    ]
----

<2> Sinon

